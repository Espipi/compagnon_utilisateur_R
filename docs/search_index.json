[
["index.html", "Le compagnon de l’utilisateur R Chapitre 1 Prérequis", " Le compagnon de l’utilisateur R Vezy Rémi 2017-06-04 Chapitre 1 Prérequis Ce livre à pour objectif de vous enseigner le plus rapidement possible comment utiliser R et son environement (RStudio, Rmarkdown, plotly…) pour la science des données. Ainsi, chaque chapitre peut être lu indépendemment des autres, pour que vous puissez aller droit à l’essentiel lorsque vous en avez besoin. Bien sûr, je vous recommande fortement de lire ou au moins de survoler le livre une première fois afin de vous faire gagner du temps par la suite. Pour donner un exemple, même si l’utilisation de plotly ne demande pas explicitement de savoir utiliser les pipes (tubes), leur utilisation ne rendra l’apprentissage que plus rapide. R peut aussi être utilisé seul mais je vous recommande fortement l’utilisation de l’IDE RStudio car il dispose d’un large panel d’outils rendant l’utilisation de R plus facile. RStudio est gratuit et libre, et la dernière version du logiciel est disponible ici. Un tutorial d’installation sera décrit en introduction. Ce livre est entièrement écrit grâce à RStudio et au package R bookdown. Vous pouvez donc vous-même télécharger bookdown et m’aider à l’écriture du livre en utilisant le lien Github. Pour cela, il vous suffit d’exécuter la commande suivante depuis la console R: devtools::install_github(&quot;rstudio/bookdown&quot;) "],
["intro.html", "Chapitre 2 Introduction 2.1 Installation 2.2 Oui, mais c’est quoi R? 2.3 Pourquoi R? 2.4 Apprendre R et trouver de l’aide", " Chapitre 2 Introduction 2.1 Installation Comme dit précédemment dans le prérequis 1, nous utiliserons R depuis RStudio, qui est un formidable environnement de développement. Il permet plusieurs choses qui seraient possibles mais plus fastidieuses depuis R seul: * Le fenêtrage: avoir dans une même fenêtre ses scripts, la console R, les graphiques, les fichiers, les packages chargés et disponibles, l’aide, ainsi que l’environnement et l’historique des commandes * Le travail en projet, que je vous décris plus tard * Un débugger * Un profiler * Une gestion du contrôle de version (GIT/SVN) Avant de commencer donc, il vous faudra installer R et RStudio. R est téléchargeable depuis le site du R-project. Il vous suffit de cliquer sur “download R”, de choisir votre mirroir, qui est le dépôt depuis lequel vous allez le télécharger (si vous avez un doute, prenez n’importe lequel en France), et enfin de cliquer sur “Download R for [votre système d’exploitation]”. Une fois téléchargé, installez-le comme n’importe quel programme. 2.2 Oui, mais c’est quoi R? R est un language de programmation dérivé du language S. Un language de programmation est ce qui permet à l’homme (le développeur ou l’utilisateur) de communiquer avec un ordinateur. En effet, les ordinateurs communiquent avec le language binaire, qui n’est composé que de 0 et de 1. Ces 0 et 1 sont agregés par “mots” pour construire des instructions. Par exemple, 01010010 veut dire R en binaire. Difficile de communiquer comme ça, dans un sens comme dans l’autre. Les languages de programmation nous servent en quelque sorte de language commun. Il en existe de nombreux, qui s’utilisent différemments. Je ne m’étendrais pas là-dessus ici, ce n’est pas le but. Mais vous pouvez retenir une chose ici: R vous sert d’outil de communication pour contrôler votre ordinateur, et lui demander d’exécuter des opérations à votre place. Je pourrais aussi ajouter que R est un language orienté objet, et un language fonctionnel. Ce sont deux paradigmes qui sont devenus très populaires et sont implémentés dans de nombreux languages informatiques (C++, Java, Python…). Le premier tourne autour de l’idée de classes et d’objets. Prenons par exemple une machine à café. Une cafetière est appelé un objet, qui est de classe cafetière. Mais le nom cafetière est parfois imprécis employé seul, car il en existe plusieurs sortes. Il y a des machines à expresso, des cafetières Italiennes, des cafetières à percolation, des cafetières à piston et j’en passe. Toutes représentent le même objet de classe cafetière. On les différenciera donc par une sous-classe -le type de cafetière-, qui partagera les attribus de la classe supérieure “cafetière”, mais qui se différencieront par d’autres attribus qu’ils n’auront pas en commun. Il existe trois différents systèmes objets orientés dans R: les S3, les S4 et les RC (Reference Classes). Ils découlent de la longue histoire du language R, qui prends ses racines en 1976, quatres ans seulement après l’invention du language orienté objet. Je décris plus en détails ces systèmes dans un autre chapitre du livre. J’ai aussi dit que R est un language fonctionnel, ce qui est entièrement lié au paradigme du language orienté objet. Il faut savoir qur R traite tout comme un objet, y compris les fonctions. Ce fonctionnement à de nombreux avantages, dont celui de pouvoir assigner une fonction à un objet, ou bien une fonction à une autre fonction. Si vous voulez avoir plus d’informations sur ce paragraphe, je vous recommande fortement de jeter un coup d’oeil au MOOC dont il est fortement inspiré, Advanced R programming de l’Université Johns-Hopkins (en anglais). Lorsqu’on débute en informatique, il arrive très souvent de penser que la machine est bête car elle ne comprends pas ce que l’on veut lui dire. On lui envoi une commande, et elle nous renvoi une erreur ou un avertissement. Si vous oubliez une virgule ou une parenthèse, le mieux qu’il puisse vous arriver est que le language reconnaisse votre erreur et qu’il vous la dise. En effet, un ordinateur n’est bête, ni intelligent. Il ne fait qu’exécuter ce que vous lui demandez. Il vous faudra donc être plus clair que jamais dans votre communication. Et par ça, je veux dire qu’il vous faudra devenir un vrai nazi de la grammaire. Une seule faute d’orthographe, et vous appelez une variable différente de celle que vous pensiez. Une seule parenthèse manquante, et votre code risque d’éxecuter une portion qu’il ne fallait pas. J’insiste beaucoup sur cette partie car vous verrez que la communication avec un ordinateur est parfois très frustante au début. Mais il faudra vous y faire, et vous rendre compte que vous et vous seuls faites des erreurs, et que c’est vous qui contrôlez l’ordinateur et non pas le contraire. 2.3 Pourquoi R? Voilà une grande question, à laquelle on peut répondre de plusieurs façons. Pour commencer, on peut se demander pourquoi utiliser un language de programmation plutôt qu’un outil a priori plus simple ? Utiliser un logiciel comme Excel ou Calc permet par exemple de visualiser ses données, effectuer des calculs, et même faire des graphiques. Alors où est l’intérêt de se compliquer la tâche pour le même résultat ? La réponse tient en deux mots: l’automatisation, et la reproductibilité. En effet, un language de programmation permet à son utilisateur d’automatiser une tâche par la description de processus, de procédures et donc d’algorithmes par l’écriture de code informatique. Mais rien de tel qu’un bon exemple pour étayer ses propos: Imaginez donc que l’on vous envoi les mêmes données chaque semaine sous la forme de plusieurs fichiers texte, et que vous deviez effectuer des opérations arithmétiques sur certains chiffres, puis calculer quelques statistiques, et enfin envoyer des graphiques récapitulatif différents à Kevin de la compta, Amar du pôle communication ou Amandine votre patrone. Si vous utilisez Excel, vous devrez répéter chaque semaine la même procédure, inlassablement. D’abord vous devrez remplir votre tableur avec les données de chaque fichier, puis appliquer vos formules aux colonnes ou aux lignes concernées, faire plusieurs graphiques, et les envoyer à vos collègues. Peu de place pour l’imaginaire. Maintenant, en utilisant un language de programmation vous avez la possibilité de coder une seule fois un script qui fera tout ceci à votre place, et même bien plus, autant de fois que vous le désirez, instantanément. Ainsi, l’auteur d’un code aura une tâche bien précise en tête, qu’il s’efforcera d’écrire sous la forme d’un script qui contiendra la ou les tâches, et qu’il pourra réexécuter autant de fois que nécessaire, sur son propre ordinateur, ou n’importe lequel. Voici qu’une machine à remplassé la pénibilité de votre travail. Vous pouvez maintenant vous concentrer sur autre chose (d’autres dossiers en attente, la dernière série Netflix, ou la paix dans le monde que sais-je?). Oui mais pourquoi R ? N’existe-t-il pas d’autres languages ? Si, bien d’autres. Il existe des languages pour à peu près tout. Il y a des languages généralistes comme C++, FORTRAN, JAVA ou encore PERL, des languages spécialisés comme HTML ou CSS, des languages compilés, des languages interprétés… Mais les languages qui nous intéressent ici sont les languages pour la science des données. Et sur ce créneau c’est la même chose, le choix est très large: SAS, Pyhton, R, Matlab, STATISTICA… Alors, pourquoi R ?? D’abord, R est gratuit, open-source, et utilisable sur Winows, Mac-OS et Linux. Ces trois arguments éliminent déjà beaucoup de concurrents sauf Pyhton, qui est considéré aujourd’hui comme la seule alternative à R. En quelques points, voici les avantages de R : R devient petit à petit la lingua franca de la science des données, poussé par une énorme communauté de développeurs, toujours grandissante. Le nombre de packages disponibles et la généricité du language, qui permettent de faire tout ce que l’on veut, des statistiques, du machine-learning, de l’édition web… Il y a cette phrase à propos de R que j’aime beaucoup: il n’y a pas de ‘est-ce que l’on peut’ avec R, mais seulement des ‘comment fait-on’. Elle résume à peu près le potentiel de ce language. R est beaucoup utilisé par les académiciens, ce qui en fait un outil toujours à la pointe des nouveaux développements. La documentation et l’aide. Dans R, chaque fonction d’un package à sa propre documentation standardisée. De par sa grande communauté, il existe aussi de nombreuses ressources comme des livres, des tutoriels youtube, des questions/réponses sur internet. R permet de faire de belles figures, de la plus simple à la plus complexe (intéractivité, D3.js, statistiques…). L’interpréteur. R est un language interprété, c’est à dire qu’il n’y a pas besoin de compiler un programme pour l’exécuter. Cela peut avoir plusieurs inconvénients, comme la rapidité d’éxécution. Mais avoir la possibilité de taper sa commande dans l’intérpréteur et d’obtenir la sortie directement est un grand avantage pour pouvoir coder vite (e.g. débuger, accéder aux valeurs instantanément…) et donc d’arriver à des résultats rapidements. La communication. R dispose de plusieurs packages (Rmarkdown, knitr, bookdown, shiny…) permettant la production de documents automatisée intégrant des figures, du code et bien d’autres choses. Le principal inconvénient de R est qu’il peut être lent si l’on utilise certains paradigmes pour coder, comme par exemple l’utilisation de boucles for, qui sont pourtant très utilisées dans d’autres languages. Ceci-dit R peut facilement être optimisé pour la rapidité si l’on connaît les bons outils. Ces outils et ses méthodes d’écritures seront détaillés dans le chapitre sur l’optimisation des codes R (mettre ref une fois chapitre existant). Enfin, au bout du compte, on peut dire que ce qui compte vraiment n’est pas le choix du language de programmation, mais plutôt ce que vous voulez en faire. Car le meilleur outil est l’outil que vous métrisez. Donc si vous voulez vous lancer dans l’apprentissage de R (ou de Python, ou de C++), lancez vous à fond, apprenez les possibilités qu’offre le language, utilisez-les pour des choses qui vous tiennent à coeur, et alors vous pourrez en faire ce que vous voudrez. 2.4 Apprendre R et trouver de l’aide Apprendre un language de programmation peut être long. La vitesse à laquelle on apprend un language par rapport à l’expérience peut se représenter grâce à une courbe d’apprentissage. Il se trouve que la courbe d’apprentissage de R n’est pas facile à déterminer, car bien souvent les personnes qui commencent ce language n’ont aucune connaissance des bases en informatique. Cependant R est un language qui dispose de nombreuses ressources d’aides sur différents formats, l’aide de R, mais aussi les livres, blogs, MOOCs, ou autres sites Q&amp;A. Pour faciliter votre apprentissage je ne peux que vous recommander de vous forcer à apprendre un peu tous les jours. Pour se faire, vous pouvez commencer par vous abonner à la liste de diffusion du blog R-bloggers, qui est un méta-blog regroupant plusieurs centaines de blogs en une seule et unique source. Vous pourrez trouver tout ce dont vous avez besoin, comme des tutoriels ou des news sur les sorties de packages. Ensuite, lorsque vous recherchez une information, vous pouvez aller faire un tour sur le site stackoverflow, qui est un site qui propose un système de question-réponse très au point, permettant le vote des meilleures réponses, ainsi que ses pages de documentations proposant des exemples ou des tutoriels autour du language R. Enfin, une façon de trouver plus vite des réponses à ses questions est d’utiliser le moteur de recherche DuckDuckGo que j’affectionne particulièrement car il propose en haut de page la réponse la mieux notée du premier site Q&amp;A qu’il trouve, avec le code associé. Celà permet très souvent de ne même pas avoir besoin d’entrer sur un site pour obtenir une réponse à sa question. Testez vous-même en suivant ce lien pour un exemple sur comment faire un graphique comprennant plusieurs graphiques de séries temporelles. De plus, ce moteur de recherche est un des seuls qui ne vous piste pas. Aussi dois-je préciser qu’il ne s’agit pas ici de publicité mais seulement de préférence personnelle. Bien sûr, la première aide à consulter avant toute est celle donnée par défaut dans chaque package. Pour y accéder sous RStudio, il vous suffit de surligner (double-cliquer) le nom de la fonction, et d’appuyer sur la touche F1 de votre clavier. Vous pouvez aussi passer par la console de R en tappant ?nom_de_la_fonction (ou help(nom_de_la_fonction)), ou encore tapper directement le nom de la fonction dans la barre de recherche de l’onglet “help” dans la fenêtre de droite. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package [@R-bookdown] in this sample book, which was built on top of R Markdown and knitr [@xie2015]. "],
["Premiers.html", "Chapitre 3 Premiers pas 3.1 Ouvrir un projet RStudio 3.2 Organiser son projet 3.3 Créer un script R 3.4 Créer des objets et les manipuler", " Chapitre 3 Premiers pas 3.1 Ouvrir un projet RStudio Pour commencer vous allez apprendre à créer votre premier projet RStudio. Travailler en projet est l’essence même du travail sous RStudio car cela apporte de nombreux avantages. En effet, un projet RStudio est un dossier contenant un projet quelconque, qui se doit être le plus indépendant possible. En effet, celui-ci contiendra toutes les étapes dont vous aurez besoin pour réaliser votre projet: les données, les scripts R ou autre, les logiciels tiers, les résultats intermédiaires et finaux, ainsi que les communications. Il est important de bien prendre connaissance de cette partie car elle conditionne de nombreuses étapes qui suivent. Croyez-moi, travailler en projet est une merveille dès qu’on a bien compris comment ça marche. Avant tout, je vous conseille de créer un dossier général nommé “R_Projects” sur votre ordinateur dans un emplacement de votre choix (qui pourra contenir beaucoup de données). Ensuite, pour commencer un projet, ouvrez RStudio, et cliquez sur File/New Project/New Directory/Empty project: Ici, RStudio vous demande un nom de projet et un emplacement dans lequel ranger votre projet. Le nom de projet doit toujours être court mais le plus explicite possible, tout en évitant les caractères spéciaux (&amp;/%-) ou les espaces (remplacez-les par “_“). Ensuite, cliquer sur browse puis choisissez l’emplacement de votre dossier R_Projects si vous l’avez déjà crée (fortement recommandé). Pour notre exemple, on nommera notre projet”Premiers_Pas_R“, et on le rangera dans le dossier”C:/R_Projects&quot; comme suit: Tada ! Vous venez de créer un projet RStudio. Maintenant il ne manque plus qu’à travailler. 3.2 Organiser son projet Un des avantages des projets est le fait que RStudio défini automatiquement le répertoire de travail à la racine du projet. Le répertoire de travail est le chemin du dossier dans lequel est situé votre projet. Dans mon exemple, celui-ci est “C:/R_Projects/Premiers_Pas_R”. Dans R, on peut modifier le répertoire de travail manuellement en utilisant la commande setwd. Par exemple, si je ne veux travailler que dans mon dossier code, je pourrais utiliser la commande: setwd(&quot;02-Code/&quot;) Le répertoire de travail sert à spécifier des chemins d’accès relatifs. En effet, pour lire un fichier qui se situe dans le répertoire 01-DATA, il existe deux façons de le faire. Soit en spécifiant le chemin complet, depuis la racine du disque : fichier= read.table(&quot;C:/R_Projects/01-DATA/fichier.txt&quot;) Soit en utilisant un chemin relatif par rapport au projet : fichier= read.table(&quot;01-DATA/fichier.txt&quot;) Cela peut paraître trivial à première vue, mais cette astuce devient très pratique lorsque les chemins deviennent longs (pensez aux chemins de la vie réelle, comme “C:/Users/username/Desktop/Docs_R/Simulations/22-01-1990/test/test2”), ou lorsque l’on partage des scripts entre collègues (pas besoin de modifier les chemins lorsqu’on passe son projet). Pour voir quel est votre répertoire de travail, vous pouvez soit le trouver écrit en haut de la console, soit simplement tapper la commande suivante: getwd() Maintenant que le répertoire de travail n’a plus de secret pour vous, nous allons l’organiser. Pour mieux comprendre comment un projet s’organise, il faut d’abord l’ouvrir dans le gestionnaire de fichiers. Pour ouvrir la fenêtre contenant le projet, vous pouvez cliquer sur More/Show Floder in New Window comme suit : Vous allez donc voir apparaître le dossier du projet dans une nouvelle fenêtre. Il n’y a rien de très intéressant à l’intérieur du projet pour l’instant: le fichier Premiers_Pas_R.Rproj et un dossier caché “.Rproj.user” (sa visibilité n’est absolument pas requise). Les fichiers .Rproj servent à ouvrir RStudio avec les paramètres du projet. Lorsque vous voulez ré-ouvrir votre projet après l’avoir quitté, il vous faudra double-cliquer sur ce fichier. Maintenant nous allons commencer à pré-organiser ce dossier. Personnellement j’aime créer une suite de dossiers numérotés dans lesquels je range des fichiers triés selon l’avancée du projet comme ceci: Le premier dossier 01-DATA contient toutes les données de départ dont à besoin le projet. Il peut s’agir d’images, de fichiers textes ou de tableurs, il seront tous présents dans ce dossier. Le second dossier 02-Code contient tous les scripts pour R ou pour tout autre logiciel, numérotés eux aussi dans l’ordre d’éxécution. En général je regroupe aussi les fonctions utilisées dans les scripts dans un seul et même script R appelé 0-Fonctions, que j’appelle ensuite depuis les autres scripts. Si vous ne comprenez rien à la phrase précédente, ne vous en faites pas nous aborderons les fonctions très vite (référence chapitre fonctions). Le troisième dossier 03-Resultats est le dossier qui contient tous les résultats, intermédiaires ou finaux. il peut s’agir de figures, de données, de modèles ou tout autre résultat du projet. Enfin, le dernier dossier 04-Communications est un dossier contenant les communications sur le projet. En effet, RStudio permet l’édition de documents pdf, word et html afin de faciliter la communication. Ce livre est d’ailleurs écrit avec Rstudio. Nous parlerons des communications dans le chapitre (mettre référence chapitre communications). Je vous incite à créer ces 4 dossiers vides à chaque fois que vous créez un nouveau projet Rstudio. Vous pouvez le faire soit manuellement, soit en utilisant la commande ci-dessous: lapply(X = list(&quot;01-DATA&quot;,&quot;02-Code&quot;,&quot;03-Resultats&quot;,&quot;04-Communications&quot;), FUN = dir.create) Attention, avant d’exécuter la commande précédente veuillez vous assurer d’avoir ouvert le projet dans RStudio, et donc que votre répertoire de travail soit bien à la source du projet ! 3.3 Créer un script R R est un language intérprété, c’est à dire qu’il interprête (exécute) vos commandes en temps réel. Vous pouvez dès à présent intéragir avec R dans l’onglet console de RStudio, qui se trouve en bas à gauche. Vous pouvez par exemple taper la commande suivante: 1+3 R vous retournera alors le résultat du calcul juste après votre commande : ## [1] 4 On vient donc de voir que R peut être utilisé comme une calculatrice, mais celui à bien plus à offrir. En effet, vous pouvez par exemple créer des objets que R sauvera dans la mémoire vive1 durant toute votre session2. Voici un premier exemple assez simple et concret: vous êtes partis en mission avec votre collègue qui a payé la totalité des frais. Pour le rembourser vous avez noté toutes les dépenses: 53.26€ de trajet, 108.30€ de repas, et 145.50€ pour la nuitée. Vous devez donc sommer toutes les dépenses et diviser par deux le total pour connaître votre part, comme ceci: (53.26+108.30+145.50)/2 ## [1] 153.53 Maintenant, si vous partez régulièrement ensemble, il peut être pratique de garder une trace de chaque élément, avec quelques explications pour chacune. Pour celà, il vous suffit de créer un script R. Un script est en fait simplement un fichier texte qui présente l’extension .R au lieu de .txt. Ce fichier sert de support pour l’écriture de commandes R. Pour créer votre premier script R, cliquez sur fichier (file) -&gt; nouveau fichier (New File) -&gt; R script, ou alors en utilisant le raccourci clavier (ctrl+shit+N). RStudio va alors ouvrir un script vierge sans titre et non sauvegardé. La première chose à faire est d’écrire un titre. Bien sûr vous ne voulez pas que R exécute le titre ou les commantaires. Pour celà, vous devez lui indiquer que la ligne que vous insérez ne doit pas être interprétée en commençant la ligne par un #. Voici un exemple, la première ligne est un commentaire, R ne l’interprète pas, alors que la seconde oui: # 2+3 5+6 ## [1] 11 Comme vous pouvez le voir R retourne 11, qui est le résultat de la deuxième ligne. Vous pouvez donc écrire votre titre de la même façon, sans que R ne s’en préoccupe: # Script R pour remboursement des frais: # Lundi 24/04/2017: 53.26€ de trajet, 108.30€ de repas, et 145.50€ pour la nuitée (53.26+108.30+145.50)/2 # Vous pouvez aussi taper un comentaire après une ligne de commande ## [1] 153.53 Pour éxécuter une ligne de commande (i.e. envoyer une ligne à R) depuis votre script, il vous suffit d’utiliser le raccourcis clavier ctrl+r, ou d’utiliser le bouton “run” dans la barre en haut de votre script. Vous pouvez maintenant enregistrer votre script en cliquant sur Fichier (File) -&gt; Enregistrer sous (save as), ou par le raccourci clavier Ctrl+s. Ensuite vous devrez nommer votre script, et je vous encourage fortement à l’enregistrer dans le dossier 02-Code si vous avez suivi le précédent point: Organiser son projet. 3.4 Créer des objets et les manipuler 3.4.1 Objet unique Maintenant que vous savez utiliser les calculs sous R et les commenter, vous allez voir comment simplifier vos scripts et vos calculs grâce à la création d’objets. Pour reprendre l’exemple précédent, nous allons créer plusieurs objet qui déterminent chacun une dépense : Trajet= 53.26 repas= 108.30 hotel= 145.50 Cette écriture est très intuitive car elle ressemble à celle que l’on écrirait sur un bout de papier. Ce qui est intéressant avec R, c’est que celui-ci enregistre la valeur associée à chaque objet, ainsi, si on éxécute le nom de l’objet, R nous retournera sa valeur : Trajet ## [1] 53.26 On peut maintenant utiliser des opération mathématiques directement sur nos objets, comme l’addition: Trajet+repas+hotel ## [1] 307.06 Et même assigner ce nouveau résultat à un nouvel objet, appelé pour l’occasion Depenses_07_Avril, qui contient les dépenses du 07 du mois d’avril: Depenses_07_Avril= Trajet+repas+hotel Notez bien la structure du code : l’objet Depenses_07_Avril est suivi d’un =, puis chaque nombre est additionné un à un. Ainsi, R fait d’abord le calcul de l’addition des objets à droite, puis assigne le résultat à l’objet nouvellement créé. On peut maintenant demander à R la valeur des dépenses : Depenses_07_Avril ## [1] 307.06 3.4.2 Vecteur La manière précédente est intéressante, mais ne permet malheureusement pas de garder une trace du calcul dans l’objet. En effet, Depenses_07_Avril ne contient que la somme des dépenses de la journée, mais pas leur détail. Pour se faire, nous pouvons créer un vecteur contenant chaque dépense de la journée : Depenses_07_Avril= c(Trajet,repas,hotel) Depenses_07_Avril ## [1] 53.26 108.30 145.50 Notez bien la structure du code ci-dessus. Chaque dépense est séparée par une virgule, et le tout est mis entre parenthèses précédées d’un c. Il est important de bien comprendre ce qu’il se passe ici. Pour faire court, nous avons créé un vecteur comportant trois nombres : 53.26, 108.30 et 145.50 rangés des objets appelés Trajet,repas et hotel repsectivement, puis nous les avons assignés à un nouvel objet Depenses_07_Avril. Maintenant, Depenses_07_Avril ne contient plus la somme de chaque dépense, mais chacune de leur valeur. En réalité, nous avons utilisé ici deux fonctions: la fonction d’assignation =, et la fonction de coercion c. Nous avons déjà vu la première, qui sert à assigner une ou des valeurs à un objet. La seconde quand à elle permet de concaténer plusieurs éléments en un seul objet qui sera un vecteur. Une vecteur est donc une suite de valeurs indépendantes. L’avantage d’un vecteur est de garder chaque valeur, et de pouvoir opérer des opérations mathématiques sur l’objet entier. Par exemple, si on veut obtenir la somme des dépenses de la journée, on pourra utiliser la fonction associée sum: Depenses_07_Avril= c(Trajet,repas,hotel) sum(Depenses_07_Avril) ## [1] 307.06 Cette fonction additione tous les éléments du vecteur. Les opérations mathématiques usuelles ont toutes leurs propres fonctions: sum(Depenses_07_Avril) # somme des éléments ## [1] 307.06 mean(Depenses_07_Avril) # moyenne des éléments ## [1] 102.3533 Depenses_07_Avril*2 # multiplication de chaque élément par 2 ## [1] 106.52 216.60 291.00 Depenses_07_Avril/2 # division de chaque élément par 2 ## [1] 26.63 54.15 72.75 Depenses_07_Avril%%2 # modulo 2 de la divison (retourne le reste de la division par deux) ## [1] 1.26 0.30 1.50 D’autres objets plus complexes existent dans R, comme les matrices, les tableaux, ou les listes. Ils seront détaillés dans le prochain chapitre. R fonctionne exclusivement avec la mémoire vive (ajouter renvoi vers chapitre optimiser R)↩ voir définition wikipédia↩ "],
["Structures.html", "Chapitre 4 Structures et types de données 4.1 Les types de données 4.2 Les transformations 4.3 Les Structures de données 4.4 Manipuler les structures 4.5 autres chapitres:", " Chapitre 4 Structures et types de données Il existe plusieurs types de données dans R, et différentes façons de les manipuler en découle. Le type de structure ou d’objet utilisé dépendra principalement de la nature de l’information à y stocker et des manipulations que l’on veut effectuer dessus. Trois principaux types de données et quatre principales structures sont utilisées régulièrement dans R. 4.1 Les types de données Les principaux types de données sont: * les charactères c(&quot;character&quot;,&quot;another one&quot;) * les doubles c(1.5,2.248,3.01) * les entiers c(1,2,3) * les booléens c(TRUE,FALSE) Il existe aussi d’autres types, dérivés ou non des types précédents comme les dates as.POSIXct(c(&quot;1990-01-01&quot;,&quot;2017-06-03&quot;)), les complexes, ou les “raw” (séquences de bits), qui ne seront pas discutés tout de suite. Il est à noter que chaque type de données contient sa propre marque pour un manque de données: le NA (not applicable: non applicable). 4.1.1 Les charactères (character) Les charactères (character) peuvent prendre n’importe quelle forme (même celle d’un chiffre), et comporter n’importe quel charactère, même un espace. Pour créer un charactère, il suffit de le déclarer entre guillemets &quot; (ou ') comme ceci: &quot;character&quot;. Ils peuvent être composés d’un seul charactère &quot;a&quot;, de plusieurs &quot;abc&quot;, ou même d’une phrase &quot;ceci est un seul charactère&quot;. Pour créer un vecteur de plusieurs charactères, il faut utiliser la fonction c() comme nous l’avons déjà vu: c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;). Voici un exemple incluant une déclaration et un test : a= &quot;a&quot; # a est un double a ## [1] &quot;a&quot; is.character(a) # teste si a est un charactère (retourne TRUE si la condition est vraie) ## [1] TRUE 4.1.2 Les doubles (double) Les doubles sont des nombres décimaux. Ils sont le type de données que vous utiliserez probablement le plus souvent. Pour les déclarer, rien de plus simple, il suffit d’écrire votre chiffre, puis de l’utiliser comme bon vous semble. Voici un petit exemple : a= 1.56 # a est un double a*83.550 # il peut être multiplié par un autre double ## [1] 130.338 is.double(a) # teste si a est un double (équivalent à is.numeric()) ## [1] TRUE Les doubles ont en plus d’autres valeurs possibles qui correspondent plutôt à des erreurs de calculs ou de précision: * le NaN, qui signifie Not a Number (= Pas un nombre). Qui est souvent le résultat d’une opération mathématique interdite, comme un logarithe ou une racine carrée d’un nombre négatif. * le -Inf et le Inf, qui sont le résultat d’une opération mathématique qui ne peut pas être calculée car trop grande ou trop petite. log(-1) ## [1] NaN 10^89999 ## [1] Inf -10^89999 ## [1] -Inf Pour bien comprendre ce type d’erreurs, et comment ils sont utilisés par R, vous devez d’abord comprendre comment un ordinateur perçoit les doubles . Je comprends que ce type d’information puisse moins vous intéresser, mais je pense fermement que vous devez connaître ceci avant de passer à la suite. Cependant, vous pouvez sauter le paragraphe qui suit pour une première lecture, et aller directement à Les entiers (integer). Cette partie peut vous paraître difficile et éloignée du sujet de prime abord, mais vous verrez par la suite à quel point elle peut être importante lors de certains calculs. Si vous lisez ce livre depuis un navigateur avec une connexion internet, je vous renvoi à l’article wikipédia sur le sujet en français ou celui en anglais encore plus complet, sinon, je vais vous faire ici un petit résumé simplifié : En informatique, un double est un type de donnée utilisé pour représenter les nombres décimaux (nombre à virgule). Comme un ordinateur utilise des suites de bits (0 ou 1) pour fonctionner, il doit représenter les nombres décimaux avec une précision donnée, c’est à dire un nombre de bits donné pour représenter un nombre. Nous les humains faisons de même. En effet, pour écrire en décimal le nombre pi, nous n’écrirons certainement pas tous les chiffres après la virgule (je vous en met au défi), mais en feront une approximation. Parfois nous écrirons 3.14 pour aller très vite, parfois lorsque la précision s’impose nous écrirons 3.141593 (ou plus). Comme un ordinateur ne peut pas savoir à l’avance avec quelle précision nous voulons travailler, nous lui imposont une précision fixe, qui aujourd’hui est le format double précision (d’où le nom de double) 64 bits de la norme (IEEE 754). Ces nombres sont représentés grâce à trois informations: le signe du nombre s (- ou +), la mantisse m (~les chiffres du nombre) et un exposant e (entier relatif qui donne la position de la virgule dans la mantisse, ce qui donne le nom de virgule flottante). Il s’agit un peu d’un équivalent de la notation scientifique. Un nombre peut donc être représenté comme ceci3 : En double précision, ces trois informations ensemble ne doivent pas dépasser 64 bits. L’encodage est donc divisé comme suit: 1 bit pour le signe, 11 bits pour l’exposant et 52 bits pour la mantisse, ce qui donne 53 bits de précision, donc environ 16 chiffres significatifs. Si vous avez bien compris comment les doubles sont encodés, alors vous aurez compris que R peut donc représenter des nombres avec beaucoup de précision, mais pas avec une précision infinie. Que vous ayez bien compris ou non, retenez ces deux conclusion: 1- La précision n’est pas infinie: Il est important de toujours garder en tête que la précision des calculs dans R n’est pas infinie, et donc que sous certaines conditions R peut présenter un comportement non valide mathématiquement, comme par exemple lors d’une soustraction de nombres extrêmement proches de zéro comme suit : 10^-325-10^-324 ## [1] 0 Comme vous pouvez le voir R retourne 0, ce qui est faux. Un calcul de cette précision peut paraître superflu mais ce genre d’erreur peut s’accumuler de calculs en calculs et devenir bien plus grande par la suite. Bien sûr, il est très rare d’utiliser de telles précisions, et les erreurs engendrées n’auront aucun impact réel sur vos calculs. Pour l’exemple, voici un autre calcul très précis, que R peut gérer (si votre ordinateur le permet) : 10^-324-10^-323 ## [1] -9.881313e-324 NB: pour voir quel degré de précision votre ordinateur (et R) peut gérer, vous pouvez regarder le contenu de l’objet .Machine dans la console de R. 2- La précision en informatique = chiffres significatifs Il faut retenir que les grands nombres ont moins de chiffres après la virgule. En effet, la précision en informatique se réfère aux chiffres significatifs, c’est à dire au nombre de chiffres que comporte un nombre au total (avant ou après la virgule). Ceci est différent de la “précision décimale”, qui se réfère au nombre de chiffres après la virgule. Comme la précision ne change pas avec le nombre considéré, plus un nombre est grand (positif ou négatif), moins on peut représenter de chiffres après sa virgule. En effet, 0.003 comporte 4 chiffres, dont 3 après la virgule. 3000 comporte 4 chiffres aussi, mais aucun après la virgule. Ils ont la même précision arithmétique au sens de chiffres significatifs (4), mais pas au sens de “précision décimale” qui donnerait 3000.0000 pour une précision de 4. Regardez par vous même, on voit que R est capable de calculer ceci : a= 10^-324-10^-323 # On teste si &quot;a&quot; est différent de 0: a!=0 ## [1] TRUE (a est bien différent de 0) Mais il ne pourra pas calculer ceci : a= 1-10^-323 # On teste si &quot;a&quot; est différent de 1: a!=1 ## [1] FALSE (a est considéré égal à 1, donc la soustraction 1-10^-323 n’est même pas prise en compte) On peu aussi noter que même si R arrive à utiliser des nombres avec de grandes précisions, celui-ci arrondi souvent le résultat lorsqu’il l’affiche dans la console. Pour voir un nombre complet, on peut utliser la fonction print() avec son argument digits, qui donne le nombre de décimale voulues, comme ceci: print(1+ 2.2e-14,digits = 22) ## [1] 1.000000000000022 Enfin, si la précision vous importe vraiment et que vous devez utilisez des chiffres plus précis que la double précision, vous pouvez jeter un oeil au package Rmpfr et le package Brobdingnag. 4.1.3 Les entiers (integer) En informatique, les entiers sont des entiers relatifs (nombre avec signe). Pour être différenciés des doubles, les entiers (integer) sont déclarés suivis de la lettre L comme suit : a= 1L b= 24L c= -500L paste(a,b,c) ## [1] &quot;1 24 -500&quot; is.integer(a) # teste si a est un entier ## [1] TRUE 4.1.4 Les booléens (boolean or logical) Les booléens sont des nombres logiques, aussi appelés variable d’état. Les booléens ont deux valeurs possibles uniquement, TRUE (vrai) et FALSE (faux). Dans R T est un raccourci pour TRUE, et F un raccourci pour FALSE. Voici comment déclarer et tester un booléen : a= TRUE b= T # équivalent de a c= FALSE d= F # équivalent de c is.logical(a) # teste si a est un booléen ## [1] TRUE 4.1.5 En bonus, les facteurs (factors) Les facteurs sont un type de données un peu spéciaux. Ils permettent d’utiliser des catégories de données dans une même variable. On peut prendre l’exemple d’une personne qui regarde de quelle couleur sont les voitures qui passent devant son entrée, s’il relève 3 voitures rouges, deux bleues et quatre blanches, alors on peut dire que nous avons trois catégories de couleurs de voitures: rouge, bleue, blanche. Pour déclarer ceci dans R, nous ferions comme suit : couleurs= factor(c(&quot;rouge&quot;,&quot;rouge&quot;,&quot;rouge&quot;,&quot;bleue&quot;,&quot;bleue&quot;,&quot;blanche&quot;,&quot;blanche&quot;,&quot;blanche&quot;,&quot;blanche&quot;)) couleurs # nous avons un vecteur de charactères, et R reconnait automatiquement les 3 catégories (levels) ## [1] rouge rouge rouge bleue bleue blanche blanche blanche blanche ## Levels: blanche bleue rouge levels(couleurs) # using the function levels() to return them ## [1] &quot;blanche&quot; &quot;bleue&quot; &quot;rouge&quot; Les facteurs sont souvent utilisés dans d’autres fonctions comme pour les graphiques ou les modèles. En général, il est préférable d’éviter leur utilisation et de leur préférer un autre type de donnée, à moins d’en avoir un réel besoin. 4.2 Les transformations R est un language extrèmement maléable, si bien qu’oil existe des “ponts” entre les types de données. On pourra donc très facilement transformer un type de données en un autre dans certains cas. 1- integer vers double : il s’agit de la transformation la plus facile. R ne requiert aucun préalable à cette transformation, si bien que celle-ci se fait sans même y réfléchir: a= 1L # a est déclaré comme un entier égal à 1 is.integer(a) # a est bien considéré comme un entier ## [1] TRUE b= a*2.5 # on multiplie a par un double et on le stocke dans b is(b) # b est lui-même un double ## [1] &quot;numeric&quot; &quot;vector&quot; 2- double to integer L’inverse n’est pas aussi simple et doit se faire en utilisant une fonction de R semblable à la fonction de test (is.integer) que nous avons déjà vu : as.integer. En voici un exemple : a= c(2,2.5,3.8) # a est déclaré comme un double is.double(a) # a est bien considéré comme un double ## [1] TRUE b= as.integer(a) # on force a à devenir un entier is(b) # b est maintenant un entier (R à tronqué le chiffre) ## [1] &quot;integer&quot; &quot;numeric&quot; &quot;vector&quot; ## [4] &quot;data.frameRowLabels&quot; 3- double (ou integer) to character: Cette transformation est aussi assez simple et peut se faire en utilisant la fonction as.character : a= c(2,2.5,3.8) # a est déclaré comme un double is.double(a) # a est bien considéré comme un double ## [1] TRUE b= as.character(a) # on force a à devenir un character b # b est maintenant un charactère (notez les guillemets qui entourent chaque chiffre) ## [1] &quot;2&quot; &quot;2.5&quot; &quot;3.8&quot; is(b) ## [1] &quot;character&quot; &quot;vector&quot; &quot;data.frameRowLabels&quot; ## [4] &quot;SuperClassMethod&quot; 3- character to double (ou integer) : Comme vous l’avez deviné, cette transformation peut se faire grâce à la fonction as.double. Cependant, il faut être très prudent lorsque l’on fait une transformation dans ce sens, car R peut parfois prendre des décisions que l’on attendais pas lorsque l’on travaille avec des facteurs. a= c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;) # a est déclaré comme un vecteur de 3 charactères is.character(a) # a est bien considéré comme un charactère ## [1] TRUE b= as.double(a) # on force a à devenir un double b # b est une version de a en double ## [1] 1 2 3 is(b) ## [1] &quot;numeric&quot; &quot;vector&quot; Maintenant un exemple avec des facteurs, qui peuvent donner des résultats inattendus lorsqu’ils sont composés de charactères comportant des chiffres et des lettres : a= factor(c(&quot;1&quot;,&quot;a&quot;,&quot;3&quot;)) # a est déclaré comme un facteur de logueur 3 b= as.numeric(a) # on force a à devenir un double b # b est bien un double, mais le résultat est quelque peu déroutant ## [1] 1 3 2 is(b) ## [1] &quot;numeric&quot; &quot;vector&quot; Comme on peut le voir, la transformation est déroutante : le “3” du facteur est devenu un 2, et le “a” un 3. Pour comprendre ce qu’il s’est passé, il faut savoir que pour transformer un facteur en numérique, R prends les catégories comme des charactères, puis les trie alphanumériquement (i.e. de 0 à 9 puis de A à Z), puis alloue l’index de chaque catégorie comme nouvelle valeur. Donc ici R à décidé de l’ordre suivant dans les catégories : “1”&lt;“3”&lt;“a”, puis leur à alloué un index : “1”=1, “3”=2, “a”=3, et a remplacé les valeurs de chaque catégorie par son index pour que “1”,“a”,“3” devienne 1,3,2. Ce type d’erreur peut être évité en utilisant la combinaison de fonctions suivantes : a= factor(c(&quot;1&quot;,&quot;a&quot;,&quot;3&quot;)) # a est déclaré comme un facteur de logueur 3 b= as.numeric(levels(a))[a] # on force a à devenir un double ## Warning: NAs introduits lors de la conversion automatique b # b est bien un double, le résultat est bon, et le charactère &quot;a&quot; est transformé en NA. ## [1] 1 NA 3 is(b) ## [1] &quot;numeric&quot; &quot;vector&quot; Maintenant que vous connaissez mieux les charactères, les doubles, les entiers, et les booléens, vous allez voir comment les organiser dans des structures de données qui vous permettront de les stocker dans des objets plus ou moins complexes. 4.3 Les Structures de données R met à disposition de ses utilisateurs quatre grands types de structures de données plus ou moins liées : les vecteurs, les matrices, les tableaux et les listes. 4.3.1 Vecteurs Nous avons déjà vu un premier exemple de vecteurs dans le chapitre précédent (Premiers pas), qui introduisait la fabrication d’un vecteur contenant des chiffres. Les vecteurs sont une structure de données à une dimension, c’est à dire qu’il s’agit d’une suite de données rangées en “ligne”. Un vecteur ne peut contenir qu’un seul type de données (charactère, booléen…) à la fois. Si l’on construit un vecteur avec plusieurs types de données consécutifs, ils sont alors transformés de la même façon que nous avons vu les tranformations précédement dans Les transformations. Il est à retenir que R essaye toujours de prendre le types de donnée qui gardera le plus d’information. Par exemple un mélange de charactères et de doubles sera transformé en charactère pour ne pas perdre l’information des charactères (qui seraient transformés en NA autrement). 4.3.2 Matrices 4.3.3 Tableaux 4.3.4 Listes 4.4 Manipuler les structures 4.4.1 Index et Test Index commence à 1 Index vecteurs [1], matrices/tableaux [1,] et listes [[,1]] ou [1] ou [[1]] Indexer plusieurs éléments: - selon numéro de l’index lignes/colonnes [1:10], [,1:10] - selon condition [c(T,T,F,T)] (test) 4.4.2 Remplacer objet[Index]= 2 objet[1:10]= 21:30 4.4.3 sous-diviser 4.4.4 Concaténation 4.4.5 Transformation Transformer un charactère en numerique et vice et versa. Transformer une matrice en tableau. 4.4.6 Transposition 4.4.7 Sous-divisier Indexer depuis un vecteur Découper un tableau en listes avec split 4.4.8 Mutliplication Chapitres d’après: ## Fonctions Disons que vous êtes en voyage au Brésil, où la monnaie est le Real, mais comme vous êtes habitué à payer Euro, vous aimeriez pouvoir convertir entre les deux simplement. A l’heure où cette version du livre à été mis à jour pour la dernière fois, 1 Euro (€) valait 3.6598 Reals (R$)4. Grâce à R, vous pouvez calculer cela très facilement en créant un objet contenant la conversion : 4.5 autres chapitres: 05- manipulations: %in%, ==, |, &amp;, || et &amp;&amp;, %*%, etc… 06- dates 07- charactères (utiliser les charctères, chercher un charactère, remplacer,…) 08- Fonctions et environnement Source de l’image↩ données Yahoo Finance téléchargées grâce à la fonction getQuote du package quantmod↩ "]
]
