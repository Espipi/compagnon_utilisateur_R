[
["index.html", "Le companion de l’utilisateur R Chapitre 1 Prérequis", " Le companion de l’utilisateur R Vezy Rémi 2017-02-26 Chapitre 1 Prérequis Ce livre à pour objectif de vous enseigner le plus rapidement possible comment utiliser R et son environement (RStudio, Rmarkdown, plotly…) pour la science des données. Ainsi, chaque chapitre peut être lu indépendemment des autres, pour que vous puissez aller droit à l’essentiel lorsque vous en avez besoin. Bien sûr, je vous recommande fortement de lire ou au moins de survoler le livre une première fois afin de vous faire gagner du temps par la suite. Pour donner un exemple, même si l’utilisation de plotly ne demande pas explicitement de savoir utiliser les pipes (tubes), leur utilisation ne rendra l’apprentissage que plus rapide. R peut aussi être utilisé seul mais je vous recommande fortement l’utilisation de l’IDE RStudio car il dispose d’un large panel d’outils rendant l’utilisation de R plus facile. RStudio est gratuit et libre, et la dernière version du logiciel est disponible ici. Un tutorial d’installation sera décrit en introduction. Ce livre est entièrement écrit grâce à RStudio et au package R bookdown. Vous pouvez donc vous-même télécharger bookdown et m’aider à l’écriture du livre en utilisant le lien Github. Pour cela, il vous suffit d’exécuter la commande suivante depuis la console R: devtools::install_github(&quot;rstudio/bookdown&quot;) "],
["intro.html", "Chapitre 2 Introduction 2.1 Installation 2.2 Oui, mais c’est quoi R? 2.3 Pourquoi R?", " Chapitre 2 Introduction 2.1 Installation Comme dit précédemment dans le prérequis 1, nous utiliserons R depuis RStudio, qui est un formidable environnement de développement. Il permet plusieurs choses qui seraient possibles mais plus fastidieuses depuis R seul: * Le fenêtrage: avoir dans une même fenêtre ses scripts, la console R, les graphiques, les fichiers, les packages chargés et disponibles, l’aide, ainsi que l’environnement et l’historique des commandes * Le travail en projet, que je vous décris plus tard * Un débugger * Un profiler * Une gestion du contrôle de version (GIT/SVN) Avant de commencer donc, il vous faudra installer R et RStudio. R est téléchargeable depuis le site du R-project. Il vous suffit de cliquer sur “download R”, de choisir votre mirroir, qui est le dépôt depuis lequel vous allez le télécharger (si vous avez un doute, prenez n’importe lequel en France), et enfin de cliquer sur “Download R for [votre système d’exploitation]”. Une fois téléchargé, installez-le comme n’importe quel programme. 2.2 Oui, mais c’est quoi R? R est un language de programmation dérivé du language S. Un language de programmation est ce qui permet à l’homme (le développeur ou l’utilisateur) de communiquer avec un ordinateur. En effet, les ordinateurs communiquent avec le language binaire, qui n’est composé que de 0 et de 1. Ces 0 et 1 sont agregés par “mots” pour construire des instructions. Par exemple, 01010010 veut dire R en binaire. Difficile de communiquer comme ça, dans un sens comme dans l’autre. Les languages de programmation nous servent en quelque sorte de language commun. Il en existe de nombreux, qui s’utilisent différemments. Je ne m’étendrais pas là-dessus ici, ce n’est pas le but. Mais vous pouvez retenir une chose ici: R vous sert d’outil de communication pour contrôler votre ordinateur, et lui demander d’exécuter des opérations à votre place. Je pourrais aussi ajouter que R est un language orienté objet, et un language fonctionnel. Ce sont deux paradigmes qui sont devenus très populaires et sont implémentés dans de nombreux languages informatiques (C++, Java, Python…). Le premier tourne autour de l’idée de classes et d’objets. Prenons par exemple une machine à café. Une cafetière est appelé un objet, qui est de classe cafetière. Mais le nom cafetière est parfois imprécis employé seul, car il en existe plusieurs sortes. Il y a des machines à expresso, des cafetières Italiennes, des cafetières à percolation, des cafetières à piston et j’en passe. Toutes représentent le même objet de classe cafetière. On les différenciera donc par une sous-classe -le type de cafetière-, qui partagera les attribus de la classe supérieure “cafetière”, mais qui se différencieront par d’autres attribus qu’ils n’auront pas en commun. Il existe trois différents systèmes objets orientés dans R: les S3, les S4 et les RC (Reference Classes). Ils découlent de la longue histoire du language R, qui prends ses racines en 1976, quatres ans seulement après l’invention du language orienté objet. Je décris plus en détails ces systèmes dans un autre chapitre du livre. J’ai aussi dit que R est un language fonctionnel, ce qui est entièrement lié au paradigme du language orienté objet. Il faut savoir qur R traite tout comme un objet, y compris les fonctions. Ce fonctionnement à de nombreux avantages, dont celui de pouvoir assigner une fonction à un objet, ou bien une fonction à une autre fonction. Si vous voulez avoir plus d’informations sur ce paragraphe, je vous recommande fortement de jeter un coup d’oeil au MOOC dont il est fortement inspiré, Advanced R programming de l’Université Johns-Hopkins (en anglais). Lorsqu’on débute en informatique, il arrive très souvent de penser que la machine est bête car elle ne comprends pas ce que l’on veut lui dire. On lui envoi une commande, et elle nous renvoi une erreur ou un avertissement. Si vous oubliez une virgule ou une parenthèse, le mieux qu’il puisse vous arriver est que le language reconnaisse votre erreur et qu’il vous la dise. En effet, un ordinateur n’est bête, ni intelligent. Il ne fait qu’exécuter ce que vous lui demandez. Il vous faudra donc être plus clair que jamais dans votre communication. Et par ça, je veux dire qu’il vous faudra devenir un vrai nazi de la grammaire. Une seule faute d’orthographe, et vous appelez une variable différente de celle que vous pensiez. Une seule parenthèse manquante, et votre code risque d’éxecuter une portion qu’il ne fallait pas. J’insiste beaucoup sur cette partie car vous verrez que la communication avec un ordinateur est parfois très frustante au début. Mais il faudra vous y faire, et vous rendre compte que vous et vous seuls faites des erreurs, et que c’est vous qui contrôlez l’ordinateur et non pas le contraire. 2.3 Pourquoi R? Voilà une grande question, à laquelle on peut répondre de plusieurs façons. Pour commencer, on peut se demander pourquoi utiliser un language de programmation plutôt qu’un outil a priori plus simple ? Utiliser un logiciel comme Excel ou Calc permet par exemple de visualiser ses données, effectuer des calculs, et même faire des graphiques. Alors où est l’intérêt de se compliquer la tâche pour le même résultat ? La réponse tient en deux mots: l’automatisation, et la reproductibilité. En effet, un language de programmation permet à son utilisateur d’automatiser une tâche par la description de processus, de procédures et donc d’algorithmes par l’écriture de code informatique. Mais rien de tel qu’un bon exemple pour étayer ses propos: Imaginez donc que l’on vous envoi les mêmes données chaque semaine sous la forme de plusieurs fichiers texte, et que vous deviez effectuer des opérations arithmétiques sur certains chiffres, puis calculer quelques statistiques, et enfin envoyer des graphiques récapitulatif différents à Kevin de la compta, Amar du pôle communication ou Amandine votre patrone. Si vous utilisez Excel, vous devrez répéter chaque semaine la même procédure, inlassablement. D’abord vous devrez remplir votre tableur avec les données de chaque fichier, puis appliquer vos formules aux colonnes ou aux lignes concernées, faire plusieurs graphiques, et les envoyer à vos collègues. Peu de place pour l’imaginaire. Maintenant, en utilisant un language de programmation vous avez la possibilité de coder une seule fois un script qui fera tout ceci à votre place, et même bien plus, autant de fois que vous le désirez, instantanément. Ainsi, l’auteur d’un code aura une tâche bien précise en tête, qu’il s’efforcera d’écrire sous la forme d’un script qui contiendra la ou les tâches, et qu’il pourra réexécuter autant de fois que nécessaire, sur son propre ordinateur, ou n’importe lequel. Voici qu’une machine à remplassé la pénibilité de votre travail. Vous pouvez maintenant vous concentrer sur autre chose (d’autres dossiers en attente, la dernière série Netflix, ou la paix dans le monde que sais-je?). Oui mais pourquoi R ? N’existe-t-il pas d’autres languages ? Si, bien d’autres. Il existe des languages pour à peu près tout. Il y a des languages généralistes comme C++, FORTRAN, JAVA ou encore PERL, des languages spécialisés comme HTML ou CSS, des languages compilés, des languages interprétés… Mais les languages qui nous intéressent ici sont les languages pour la science des données. Et sur ce créneau c’est la même chose, le choix est très large: SAS, Pyhton, R, Matlab, STATISTICA… Alors, pourquoi R ?? D’abord, R est gratuit, open-source, et utilisable sur Winows, Mac-OS et Linux. Ces trois arguments éliminent déjà beaucoup de concurrents sauf Pyhton, qui est considéré aujourd’hui comme la seule alternative à R. En quelques points, voici les avantages de R : R devient petit à petit la lingua franca de la science des données, poussé par une énorme communauté de développeurs, toujours grandissante. Le nombre de packages disponibles et la généricité du language, qui permettent de faire tout ce que l’on veut, des statistiques, du machine-learning, de l’édition web… Il y a cette phrase à propos de R que j’aime beaucoup: il n’y a pas de ‘est-ce que l’on peut’ avec R, mais seulement des ‘comment fait-on’. Elle résume à peu près le potentiel de ce language. R est beaucoup utilisé par les académiciens, ce qui en fait un outil toujours à la pointe des nouveaux développements. La documentation et l’aide. Dans R, chaque fonction d’un package à sa propre documentation standardisée. De par sa grande communauté, il existe aussi de nombreuses ressources comme des livres, des tutoriels youtube, des questions/réponses sur internet. R permet de faire de belles figures, de la plus simple à la plus complexe (intéractivité, D3.js, statistiques…). L’interpréteur. R est un language interprété, c’est à dire qu’il n’y a pas besoin de compiler un programme pour l’exécuter. Cela peut avoir plusieurs inconvénients, comme la rapidité d’éxécution. Mais avoir la possibilité de taper sa commande dans l’intérpréteur et d’obtenir la sortie directement est un grand avantage pour pouvoir coder vite (e.g. débuger, accéder aux valeurs instantanément…) et donc d’arriver à des résultats rapidements. La communication. R dispose de plusieurs packages (Rmarkdown, knitr, bookdown, shiny…) permettant la production de documents automatisée intégrant des figures, du code et bien d’autres choses. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package [@R-bookdown] in this sample book, which was built on top of R Markdown and knitr [@xie2015]. "]
]
